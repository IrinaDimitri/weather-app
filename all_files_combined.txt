.
├── Makefile
├── all_files_combined.txt
└── main
    ├── java
    │   └── com
    │       └── example
    │           ├── WeatherApp.java
    │           ├── WeatherController.java
    │           ├── config
    │           │   └── SwaggerConfig.java
    │           ├── model
    │           │   └── Weather.java
    │           ├── repository
    │           │   └── WeatherRepository.java
    │           └── service
    │               └── WeatherService.java
    └── resources
        ├── application.properties
        └── data.sql

9 directories, 10 files


=== FILE CONTENTS ===

FILE: ./main/java/com/example/config/SwaggerConfig.java
package com.example.config;

import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.info.Contact;
import io.swagger.v3.oas.annotations.info.Info;
import io.swagger.v3.oas.annotations.info.License;
import io.swagger.v3.oas.annotations.servers.Server;
import org.springframework.context.annotation.Configuration;

@Configuration
@OpenAPIDefinition(
    info = @Info(
        title = "Weather API",
        version = "3.0.2",
        description = "API для управления данными о погоде",
        contact = @Contact(
            name = "Irina Dimitrieva",
            email = "irina@example.com"
        ),
        license = @License(
            name = "MIT License",
            url = "https://opensource.org/licenses/MIT"
        )
    ),
    servers = {
        @Server(
            url = "http://localhost:8080",
            description = "Локальный сервер"
        ),
        @Server(
            url = "http://api.weather.example.com",
            description = "Продакшен сервер"
        )
    }
)
public class SwaggerConfig {
}

FILE: ./main/java/com/example/model/Weather.java
package com.example.model;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name = "weather")
@Schema(description = "Модель данных о погоде в городе")
public class Weather {
    @Id
    @Schema(description = "Название города", example = "Berlin")
    private String city;
    
    @Schema(description = "Температура в градусах Цельсия", example = "20")
    private int temperature;

    public Weather() {}

    public Weather(String city, int temperature) {
        this.city = city;
        this.temperature = temperature;
    }

    // Геттеры и сеттеры остаются без изменений
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public int getTemperature() {
        return temperature;
    }

    public void setTemperature(int temperature) {
        this.temperature = temperature;
    }
}
FILE: ./main/java/com/example/repository/WeatherRepository.java
package com.example.repository;

import com.example.model.Weather;
import org.springframework.data.jpa.repository.JpaRepository;

public interface WeatherRepository extends JpaRepository<Weather, String> {
}
FILE: ./main/java/com/example/service/WeatherService.java
package com.example.service;
import org.springframework.scheduling.annotation.Scheduled;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import com.example.model.Weather;
import com.example.repository.WeatherRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.Map;

@Slf4j
@Service
@Tag(name = "Weather Service", description = "Сервис для получения и обновления данных о погоде")
public class WeatherService {
    private static final String API_URL = "https://api.open-meteo.com/v1/forecast";
    private final WeatherRepository weatherRepo;

    private static final Map<String, double[]> CITIES = Map.of(
        "Berlin", new double[]{52.52, 13.41},
        "London", new double[]{51.51, -0.13},
        "Paris", new double[]{48.85, 2.35}
    );

    @Autowired
    public WeatherService(WeatherRepository weatherRepo) {
        this.weatherRepo = weatherRepo;
    }

    // @PostConstruct
    // @Scheduled(fixedRateString = "${weather.update.interval}")
    //     public void scheduledUpdate() {
    //     log.info("Запуск обновления данных по расписанию");
    //     updateAllCities();
    // }
    // public void updateAllCities() {
    //     weatherRepo.findAll().forEach(weather -> {
    //         log.info("Обновление данных для всех городов...");
    //         try {
    //             updateCityWeather(weather.getCity());
    //         } catch (Exception e) {
    //             log.error("Ошибка при обновлении города {}: {}", weather.getCity(), e.getMessage());
    //             saveDefaultTemp(weather.getCity());
    //         }
    //     });
    // }

    // @Operation(
    //     summary = "Обновить данные о погоде для города",
    //     description = "Обновляет данные о погоде для указанного города из внешнего API и сохраняет в базе данных.",
    //     responses = {
    //         @ApiResponse(
    //             responseCode = "200",
    //             description = "Данные о погоде успешно обновлены",
    //             content = @Content(mediaType = "application/json")
    //         ),
    //         @ApiResponse(
    //             responseCode = "404",
    //             description = "Город не найден в базе данных",
    //             content = @Content(mediaType = "application/json")
    //         )
    //     }
    // )
    // public boolean updateCityWeather(String city) throws Exception {
    //     double[] coords = getCityCoordinates(city);
    //     double temperature = fetchCurrentTemperature(coords[0], coords[1]);
    //     Weather weather = weatherRepo.findById(city).orElse(new Weather(city, 0));
    //     weather.setTemperature((int) Math.round(temperature));
    //     weatherRepo.save(weather);
    //     return true;
    // }

    @Operation(
        summary = "Обновить данные о погоде для всех городов",
        description = "Обновляет данные о погоде для всех городов в базе данных.",
        responses = {
            @ApiResponse(
                responseCode = "200",
                description = "Данные о погоде успешно обновлены для всех городов",
                content = @Content(mediaType = "application/json")
            ),
            @ApiResponse(
                responseCode = "500",
                description = "Ошибка обновления данных",
                content = @Content(mediaType = "application/json")
            )
        }
    )

    private void saveDefaultTemp(String city) {
        Weather weather = weatherRepo.findById(city).orElse(new Weather(city, 0));
        weather.setTemperature(20); // Значение по умолчанию
        weatherRepo.save(weather);
    }

    private double[] getCityCoordinates(String city) {
        if (CITIES.containsKey(city)) {
            return CITIES.get(city);
        }
        throw new IllegalArgumentException("Город не найден: " + city);
    }

    @Operation(
        summary = "Получить текущую температуру для города",
        description = "Получает текущую температуру для указанного города через API Open-Meteo.",
        responses = {
            @ApiResponse(
                responseCode = "200",
                description = "Температура успешно получена",
                content = @Content(mediaType = "application/json")
            ),
            @ApiResponse(
                responseCode = "500",
                description = "Ошибка при получении температуры",
                content = @Content(mediaType = "application/json")
            )
        }
    )
    public double fetchCurrentTemperature(double latitude, double longitude) throws Exception {
        RestTemplate restTemplate = new RestTemplate();
        String url = String.format("%s?latitude=%f&longitude=%f&current_weather=true", API_URL, latitude, longitude);
        String response = restTemplate.getForObject(url, String.class);

        ObjectMapper mapper = new ObjectMapper();
        JsonNode root = mapper.readTree(response);
        return root.path("current_weather").path("temperature").asDouble();
    }
}

FILE: ./main/java/com/example/WeatherApp.java
package com.example;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WeatherApp {
    public static void main(String[] args) {
        SpringApplication.run(WeatherApp.class, args);
    }
}
FILE: ./main/java/com/example/WeatherController.java
package com.example.controller;

import com.example.model.Weather;
import com.example.repository.WeatherRepository;
import com.example.service.WeatherService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.List;

@RestController
@Tag(name = "Weather API", description = "Управление данными о погоде")
public class WeatherController {

    private final WeatherRepository weatherRepository;
    private final WeatherService weatherService;
    private static final Logger log = LoggerFactory.getLogger(WeatherController.class);

    public WeatherController(WeatherRepository weatherRepository, WeatherService weatherService) {
        this.weatherRepository = weatherRepository;
        this.weatherService = weatherService;
    }

    @GetMapping(value = "/ping", produces = MediaType.TEXT_HTML_VALUE)
    public ResponseEntity<String> ping() {
        log.info("Ping запрос");
        return ResponseEntity.ok("<html><body><h1>PONG</h1></body></html>");
    }

    @GetMapping(value = "/health", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> health() {
        log.info("Запрос состояния сервиса");
        return ResponseEntity.ok("{\"status\": \"HEALTHY\"}");
    }

    @GetMapping(value = "/list", produces = MediaType.TEXT_HTML_VALUE)
    public ResponseEntity<String> list() {
        log.info("Запрос списка всех городов с погодой");
        List<Weather> weatherList = weatherRepository.findAll();
        if (weatherList.isEmpty()) {
            log.warn("Список городов пуст");
            return ResponseEntity.status(HttpStatus.NO_CONTENT)
                .body("<html><body><h2>Информация</h2><p>Список городов с погодой пока пуст.</p></body></html>");
        }

        StringBuilder html = new StringBuilder("<html><body><ul>");
        for (Weather weather : weatherList) {
            html.append("<li>")
                .append(escapeHtml(weather.getCity()))
                .append(": ")
                .append(weather.getTemperature())
                .append("°C</li>");
        }
        html.append("</ul></body></html>");
        return ResponseEntity.ok(html.toString());
    }

    @Operation(
        summary = "Добавить или обновить данные о погоде",
        description = "Добавляет новый город или обновляет данные о погоде существующего города в базе данных",
        responses = {
            @ApiResponse(
                responseCode = "200",
                description = "Данные успешно добавлены/обновлены",
                content = @Content(mediaType = "text/html")
            ),
            @ApiResponse(
                responseCode = "400",
                description = "Неверные параметры запроса"
            ),
            @ApiResponse(
                responseCode = "500",
                description = "Внутренняя ошибка сервера"
            )
        }
    )
    @PostMapping(value = "/add", produces = MediaType.TEXT_HTML_VALUE)
    public ResponseEntity<String> add(
        @RequestParam String city,
        @RequestParam(required = false) Integer temperature,
        @RequestParam(defaultValue = "false") boolean forceUpdate
    ) {
        log.info("Запрос добавления или обновления данных для города: {}", city);

        if (city == null || city.trim().isEmpty()) {
            String msg = "Параметр 'city' не должен быть пустым.";
            log.error(msg);
            return ResponseEntity.badRequest().body(errorHtml(msg));
        }
        if (!city.matches("[a-zA-Z\\s-]+")) {
            String msg = "Название города должно содержать только латинские буквы, пробелы или дефисы.";
            log.error(msg + " Получено: " + city);
            return ResponseEntity.badRequest().body(errorHtml(msg));
        }

        try {
            int tempToSave;
            String updateInfo;

            if (temperature != null) {
                tempToSave = temperature;
                updateInfo = "<p>Температура установлена вручную.</p>";
            } else {
                // Здесь можно интегрировать вызов внешнего API или сервиса для получения температуры
                tempToSave = 20; // заглушка
                updateInfo = "<p>Температура не указана. Использовано значение по умолчанию: 20°C.</p>";
            }

            boolean cityExists = weatherRepository.existsById(city);
            if (cityExists && !forceUpdate) {
                String msg = "Город \"" + city + "\" уже существует в базе данных. " +
                             "Для обновления данных используйте параметр forceUpdate=true.";
                log.warn(msg);
                return ResponseEntity.status(HttpStatus.CONFLICT).body(errorHtml(msg));
            }

            weatherRepository.save(new Weather(city, tempToSave));
            log.info("Город {} успешно {} с температурой {}°C", city, cityExists ? "обновлен" : "добавлен", tempToSave);

            return ResponseEntity.ok(
                "<html><body><h2>Успех!</h2>" +
                "<p>Город \"" + escapeHtml(city) + "\" " +
                (cityExists ? "обновлен" : "добавлен") +
                " с температурой " + tempToSave + "°C.</p>" +
                updateInfo +
                "</body></html>"
            );

        } catch (Exception e) {
            String errorMsg = "Внутренняя ошибка сервера при сохранении данных: " + e.getMessage();
            log.error(errorMsg, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorHtml(errorMsg));
        }
    }

    // @Operation(
    //     summary = "Обновить данные о погоде для города",
    //     description = "Обновляет данные о погоде для указанного города из внешнего API и сохраняет в базе данных.",
    //     responses = {
    //         @ApiResponse(
    //             responseCode = "200",
    //             description = "Данные о погоде успешно обновлены",
    //             content = @Content(mediaType = "application/json")
    //         ),
    //         @ApiResponse(
    //             responseCode = "404",
    //             description = "Город не найден в базе данных и/или в Open Weather API",
    //             content = @Content(mediaType = "application/json")
    //         )
    //     }
    // )

    // @PostMapping(value = "/update", produces = MediaType.TEXT_HTML_VALUE)
    // public ResponseEntity<String> updateWeather(
    //     @RequestParam(required = false) String city
    // ) {
    //     log.info("Запрос обновления данных о погоде для города: {}", city);
    //     try {
    //         if (city == null || city.trim().isEmpty()) {
    //             weatherService.updateAllCities();
    //             return ResponseEntity.ok(
    //                 "<html><body><h2>Успех!</h2><p>Данные о погоде для всех городов успешно обновлены.</p></body></html>");
    //         } else {
    //             boolean updated = weatherService.updateCityWeather(city);
    //             if (!updated) {
    //                 String msg = "Город \"" + city + "\" не найден в базе данных.";
    //                 log.warn(msg);
    //                 return ResponseEntity.status(HttpStatus.NOT_FOUND)
    //                         .body(errorHtml(msg));
    //             }
    //             log.info("Данные о погоде для города {} успешно обновлены", city);
    //             return ResponseEntity.ok(
    //                 "<html><body><h2>Успех!</h2><p>Данные о погоде для города \"" + escapeHtml(city) + "\" успешно обновлены.</p></body></html>");
    //         }
    //     } catch (Exception e) {
    //         String errorMsg = "Внутренняя ошибка сервера при обновлении данных: " + e.getMessage();
    //         log.error(errorMsg, e);
    //         return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
    //                 .body(errorHtml(errorMsg));
    //     }
    // }

    @DeleteMapping(value = "/delete", produces = MediaType.TEXT_HTML_VALUE)
    public ResponseEntity<String> delete(
        @RequestParam(required = false) String city,
        @RequestParam(defaultValue = "false") boolean all
    ) {
        log.info("Запрос удаления данных для города: {}, удаление всех данных: {}", city, all);
        try {
            if (all) {
                weatherRepository.deleteAll();
                log.info("Все данные о погоде успешно удалены");
                return ResponseEntity.ok(
                    "<html><body><h2>Успех!</h2><p>Все данные о погоде успешно удалены.</p></body></html>");
            }

            if (city == null || city.trim().isEmpty()) {
                String msg = "Для удаления конкретного города необходимо указать параметр 'city', " +
                             "или установите параметр all=true для удаления всех данных.";
                log.error(msg);
                return ResponseEntity.badRequest().body(errorHtml(msg));
            }

            if (!weatherRepository.existsById(city)) {
                String msg = "Город \"" + city + "\" не найден в базе данных, удаление невозможно.";
                log.warn(msg);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorHtml(msg));
            }

            weatherRepository.deleteById(city);
            log.info("Город {} успешно удален", city);
            return ResponseEntity.ok(
                "<html><body><h2>Успех!</h2><p>Город \"" + escapeHtml(city) + "\" успешно удален.</p></body></html>");
        } catch (Exception e) {
            String errorMsg = "Внутренняя ошибка сервера при удалении данных: " + e.getMessage();
            log.error(errorMsg, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorHtml(errorMsg));
        }
    }

    private String errorHtml(String message) {
        return "<html><body><h2>Ошибка!</h2><p>" + escapeHtml(message) + "</p></body></html>";
    }

    private String escapeHtml(String input) {
        if (input == null) return "";
        return input.replace("&", "&amp;")
                    .replace("<", "&lt;")
                    .replace(">", "&gt;")
                    .replace("\"", "&quot;")
                    .replace("'", "&#39;");
    }
}

FILE: ./main/resources/application.properties
spring.jpa.hibernate.ddl-auto=update
logging.file.name=/app/logs/weather-app.log
spring.datasource.url=jdbc:postgresql://localhost:5432/weather_db
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.show-sql=true
spring.sql.init.mode=always

FILE: ./main/resources/data.sql
CREATE TABLE IF NOT EXISTS weather (
    city TEXT PRIMARY KEY,
    temperature INT
);

DELETE FROM weather;
INSERT INTO weather (city, temperature) VALUES 
  ('London', 20), 
  ('Paris', 15), 
  ('Moscow', 17);

FILE: ./Makefile
